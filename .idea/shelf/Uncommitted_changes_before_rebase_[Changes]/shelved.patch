Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import arcade.gui\nfrom die_arcade import DIE_X, DIE_Y, Die\nfrom checkboxes import Button\nimport time\nfrom typing import List\nfrom player import *\nimport room_dimensions\n\n# Set how many rows and columns we will have\nROW_COUNT = 24\nCOLUMN_COUNT = 34\n\nTIME = 0.5\n\n# This sets the WIDTH and HEIGHT of each grid location\nWIDTH = 30\nHEIGHT = 30\n\n# This sets the margin between each cell and offset for screen edges\nMARGIN = 2\n\n# Screen dimensions\nSCREEN_WIDTH = (WIDTH + MARGIN) * COLUMN_COUNT + MARGIN\nSCREEN_HEIGHT = (HEIGHT + MARGIN) * ROW_COUNT + MARGIN\nSCREEN_TITLE = \"Clue\"\n\n# Width of Sidebar\nSIDEBAR_WIDTH = 320\n\n# Sprite settings\nPLAYER_MOVEMENT = 32\nSPRITE_SCALING = 0.06\n\n\n# starting view, class\nclass StartView(arcade.View):\n    def __init__(self, width, height):\n        super().__init__()\n        self.width = width\n        self.height = height\n        self.background_img = arcade.load_texture(\"../../clue_image.jpeg\")\n        arcade.load_font(\"../../bulletin-gothic/BulletinGothic.otf\")\n        self.text_effect = 0\n        self.min_font_size_reached = True\n        self.max_font_size_reached = False\n\n    def on_mouse_press(self, _x, _y, _button, _modifiers):\n        \"\"\" If the user presses the mouse button, start the game. \"\"\"\n        clueGameView = ClueGameView(self.width, self.height)\n        self.window.show_view(clueGameView)\n\n    def on_draw(self):\n        \"\"\" Draw this view \"\"\"\n        self.clear()\n        # example text\n        text = \"Click\"\n        # Draw the background texture\n        arcade.draw_lrwh_rectangle_textured(0, 0,\n                                            self.width, self.height,\n                                            self.background_img)\n        # sets text size to initial small size, and adds text_effect at each iteration, which increases and decreases,\n        # pulsating.\n        text_size = 25 + self.text_effect\n\n        arcade.draw_text(text, self.window.width / 2, self.window.height / 2 - 150,\n                         arcade.color.FLORAL_WHITE, font_name=\"Bulletin Gothic\", font_size=text_size, anchor_x=\"center\")\n\n        # flags min and max font size reached, tells font when to steadily decrease or increase until other flag is set\n        # this keeps font size within an interval, 25 & 100 (text size + text_effect which grows to 75).\n        # time sleep to slow pulsating\n        if self.text_effect <= 75 and self.min_font_size_reached:\n            self.text_effect += 1\n            time.sleep(0.03)\n            if self.text_effect == 75:\n                self.max_font_size_reached = True\n                self.min_font_size_reached = False\n        elif self.text_effect >= 25 and self.max_font_size_reached:\n            self.text_effect -= 1\n            time.sleep(0.05)\n            if self.text_effect == 25:\n                self.max_font_size_reached = False\n                self.min_font_size_reached = True\n        print(self.text_effect)\n\n    def on_show_view(self):\n        \"\"\" This is run once when we switch to this view \"\"\"\n        arcade.set_background_color(arcade.csscolor.DARK_SLATE_BLUE)\n\n\nclass ClueGameView(arcade.View):  # (arcade.Window)\n    def __init__(self, width, height):\n        super().__init__()\n        # super().__init__(width, height, title)\n        self.width = width\n        self.height = height\n\n        # We can quickly build a grid with python list comprehension\n        self.grid = [[0] * COLUMN_COUNT for _ in range(ROW_COUNT)]\n\n        # Set the window's background color\n        self.background_color = arcade.color.BLACK\n\n        # Create a dictionary to store room locations\n        self.rooms = {'study': room_dimensions.study, 'hall': room_dimensions.hall, 'lounge': room_dimensions.lounge,\n                      'library': room_dimensions.library, 'billiard_room': room_dimensions.billiard_room,\n                      'conservatory': room_dimensions.conservatory, 'ballroom': room_dimensions.ballroom,\n                      'kitchen': room_dimensions.kitchen, 'dining-room': room_dimensions.dining_room,\n                      'guessing_room': room_dimensions.guessing_room}\n\n        # Player Info\n        self.player_names = [\"Scarlet\", \"Plum\", \"Peacock\", \"Mustard\", \"Green\", \"White\"]\n\n        self.player_xs = [753, 17, 17, 497, 753, 561]\n\n        self.player_ys = [241, 625, 209, 753, 561, 17]\n\n        self.player_npcs = []\n\n        self.players = []\n\n        # Sprite Info\n        self.grid_sprite_list = arcade.SpriteList()\n\n        self.player_list = arcade.SpriteList()\n\n        self.ms_scarlet = Player(\"images/Red-Circle-Transparent.png\", 0.06)\n\n        self.ms_scarlet.center_x = self.player_xs[0]\n\n        self.ms_scarlet.center_y = self.player_ys[0]\n\n        self.player_list.append(self.ms_scarlet)\n\n        self.prof_plum = Player(\"images//Purple_Circle.png\", 0.065)\n\n        self.prof_plum.center_x = self.player_xs[1]\n\n        self.prof_plum.center_y = self.player_ys[1]\n\n        self.player_list.append(self.prof_plum)\n\n        self.mrs_peacock = Player(\"images/Pan_Blue_Circle.png\", 0.045)\n\n        self.mrs_peacock.center_x = self.player_xs[2]\n\n        self.mrs_peacock.center_y = self.player_ys[2]\n\n        self.player_list.append(self.mrs_peacock)\n\n        self.col_mustard = Player(\"images/Yellow_Circle.png\", 0.065)\n\n        self.col_mustard.center_x = self.player_xs[3]\n\n        self.col_mustard.center_y = self.player_ys[3]\n\n        self.player_list.append(self.col_mustard)\n\n        self.mayor_green = Player(\"images/—Pngtree—circle clipart green circle_5553152.png\", 0.028)\n\n        self.mayor_green.center_x = self.player_xs[4]\n\n        self.mayor_green.center_y = self.player_ys[4]\n\n        self.player_list.append(self.mayor_green)\n\n        self.chef_white = Player(\"images/open-circle-ring-transparent-png-png-see-through-background.png\", 0.027)\n\n        self.chef_white.center_x = self.player_xs[5]\n\n        self.chef_white.center_y = self.player_ys[5]\n\n        self.player_list.append(self.chef_white)\n\n        self.turn = True\n\n        self.moves = 0\n\n        self.press = 0\n\n        self.idle = 50\n\n        self.limit = 6\n\n        self.left_pressed = False\n\n        self.right_pressed = False\n\n        self.up_pressed = False\n\n        self.down_pressed = False\n\n        self.current_player = 0\n\n        self.move_list = []\n\n        for player in self.player_list:\n            self.players.append(player)\n\n        for player in self.players:\n            self.player_npcs.append(player)\n        self.player_npcs.remove(self.player_npcs[0])\n\n        # Create a list of solid-color sprites to represent each grid location\n        for row in range(ROW_COUNT):\n            for column in range(COLUMN_COUNT):\n                x = column * (WIDTH + MARGIN) + (WIDTH / 2 + MARGIN)\n                y = row * (HEIGHT + MARGIN) + (HEIGHT / 2 + MARGIN)\n                sprite = arcade.SpriteSolidColor(WIDTH, HEIGHT, arcade.color.FLORAL_WHITE)\n                sprite.center_x = x\n                sprite.center_y = y\n                self.grid_sprite_list.append(sprite)\n\n        # Room generation\n        self.room_sprite_list = arcade.SpriteList()\n        self.roomList = self.generate_rooms()\n\n        for self.room in self.roomList:\n            self.room_sprite_list.append(self.room)\n\n        # Resyncing\n        self.resync_grid_with_sprites()\n\n        # adding die to sidebar as class object\n        self.die = Die(DIE_X, DIE_Y, 50, 50)\n        # bool to control whether die appears or not\n        self.die_visible = True\n\n        # adding class object, sidebar buttons\n        self.sidebar_buttons = []\n        self.draw_sidebar_buttons()\n\n    # Method for reloading sprites after I/O or other changes\n    def resync_grid_with_sprites(self):\n        for row in range(ROW_COUNT):\n            for column in range(COLUMN_COUNT):\n                pos = row * COLUMN_COUNT + column\n                if self.grid[row][column] == 0:\n                    self.grid_sprite_list[pos].color = arcade.color.GRAY\n\n    def get_color_for_room(self, room):\n        room_colors = {\n            'lounge': arcade.color.JET,\n            'library': arcade.color.ANTIQUE_BRASS,\n            'hall': arcade.color.APRICOT,\n            'study': arcade.color.CORDOVAN,\n            'billiard_room': arcade.color.BITTERSWEET_SHIMMER,\n            'conservatory': arcade.color.BRIGHT_UBE,\n            'ballroom': arcade.color.DARK_LIVER,\n            'kitchen': arcade.color.KHAKI,\n            'dining-room': arcade.color.FIELD_DRAB,\n            'guessing_room': arcade.color.BLACK\n\n        }\n        return room_colors.get(room, arcade.color.BURNT_ORANGE)\n\n    # Method for creating and returning a list of the classic rooms from Clue\n    def generate_rooms(self):\n        # Hall, Lounge, Dining Room, Kitchen, Ballroom, Conservatory, Billiard Room, Library, and Study\n        hall = Room(\"hall\", \"\", [[19, 8], [16, 11], [16, 12]], \"images/hall.jpeg\", .99)\n        lounge = Room(\"lounge\", \"conservatory\", [[17, 17]], \"images/lounge.jpeg\", 1)\n        clue_room = Room(\"clue_room\", \"\", [], \"images/clue-room.jpeg\", 1)\n        dining_room = Room(\"dining_room\", \"\", [[11, 15], [15, 17]], \"images/dining-room.png\", .399)\n        kitchen = Room(\"kitchen\", \"study\", [[6, 19]], \"images/kitchen.jpeg\", 1)\n        ballroom = Room(\"ballroom\", \"\", [[4, 7], [4, 16]], \"images/ballroom.png\", .4)\n        conservatory = Room(\"conservatory\", \"lounge\", [[4, 6]], \"images/conservatory.png\", .4)\n        billiard_room = Room(\"billiard_room\", \"\", [[8, 6], [12, 1]], \"images/billiard.jpeg\", 1)\n        library = Room(\"library\", \"\", [[12, 3], [15, 7]], \"images/library.png\", .4)\n        study = Room(\"study\", \"kitchen\", [[19, 6]], \"images/study.jpeg\", 1)\n\n        return [hall, lounge, study, clue_room, dining_room, billiard_room, kitchen, conservatory, ballroom, library]\n\n    # Dice Roll event caller\n    def on_click_roll(self, event):\n        print(\"Roll:\", event)\n\n    # Method  that randomly selects three cards for the case file\n    def get_case_file(self, deck):\n        one_of_each_list = [\"character\", \"room\", \"weapon\"]\n        case_file = []\n        for card in deck:\n            if card.cardType in one_of_each_list:\n                case_file.append(card)\n                one_of_each_list.remove(card.cardType)\n                deck.remove(card)\n        return case_file\n\n    # Method for drawing sidebar\n    def draw_sidebar(self):\n        arcade.draw_rectangle_filled(\n            self.width - SIDEBAR_WIDTH / 2,\n            self.height / 2,\n            SIDEBAR_WIDTH,\n            self.height,\n            arcade.color.LIGHT_BROWN\n        )\n        y_value = 780\n        for card_type in [\"Weapons\", \"Rooms\", \"Players\"]:\n            y_value -= 30\n            if card_type == \"Players\":\n                y_value -= 50\n            arcade.draw_text(card_type, self.width - SIDEBAR_WIDTH + 10, y_value,\n                             arcade.color.BLACK, 12, width=180, align=\"left\", anchor_x=\"left\", anchor_y=\"top\")\n            y_value -= 105\n        \"\"\"\n        deck = Deck.initialize_cards()\n        characters = ['Miss Scarlett', 'Colonel Mustard', 'Mrs. White', 'Mr. Green', 'Mrs. Peacock',\n                      'Professor Plum']\n        rooms = ['Kitchen', 'Ballroom', 'Conservatory', 'Dining Room', 'Billiard Room', 'Library', 'Lounge',\n                 'Hall', 'Study']\n        weapons = ['Candlestick', 'Dagger', 'Lead Pipe', 'Revolver', 'Rope', 'Wrench']\n        #self.checkbox_states = {item: False for item in weapons + rooms + characters}\n        y_value = 780\n        for card_type, items in [(\"Weapons\", weapons), (\"Rooms\", rooms), (\"Players\", characters)]:\n            y_value -= 30\n            # adding button objects so that checkboxes can be clickable\n            self.sidebar_buttons.append(Button(self.width - SIDEBAR_WIDTH + 10, y_value, 10, 10, card_type))\n            #arcade.draw_text(card_type, self.width - SIDEBAR_WIDTH + 10, y_value,\n                             #arcade.color.BLACK, 12, width=180, align=\"left\", anchor_x=\"left\", anchor_y=\"top\")\n            y_value -= 12\n            for item in items:\n                y_value -= 16\n                # adding button objects so that checkboxes can be clickable\n                self.sidebar_buttons.append(Button(self.width - SIDEBAR_WIDTH + 150, y_value, 10, 10, item))\n                #arcade.draw_rectangle_filled(self.width - SIDEBAR_WIDTH + 150, y_value, 10, 10, arcade.color.BLACK)\n                #arcade.draw_text(item, self.width - SIDEBAR_WIDTH + 10, y_value + 8,\n                                 #arcade.color.BLACK, 9, width=180, align=\"left\", anchor_x=\"left\", anchor_y=\"top\")\n        \"\"\"\n\n    def draw_sidebar_buttons(self):\n        # deck = Deck.initialize_cards()\n        characters = ['Miss Scarlett', 'Colonel Mustard', 'Mrs. White', 'Mr. Green', 'Mrs. Peacock',\n                      'Professor Plum']\n        rooms = ['Kitchen', 'Ballroom', 'Conservatory', 'Dining Room', 'Billiard Room', 'Library', 'Lounge',\n                 'Hall', 'Study']\n        weapons = ['Candlestick', 'Dagger', 'Lead Pipe', 'Revolver', 'Rope', 'Wrench']\n        # self.checkbox_states = {item: False for item in weapons + rooms + characters}\n        y_value = 780\n        for card_type, items in [(\"Weapons\", weapons), (\"Rooms\", rooms), (\"Players\", characters)]:\n            y_value -= 30\n            # adding button objects so that checkboxes can be clickable\n            # self.sidebar_buttons.append(Button(self.width - SIDEBAR_WIDTH + 10, y_value, 10, 10, card_type))\n            arcade.draw_text(card_type, self.width - SIDEBAR_WIDTH + 10, y_value,\n                             arcade.color.BLACK, 12, width=180, align=\"left\", anchor_x=\"left\", anchor_y=\"top\")\n            y_value -= 12\n            for item in items:\n                y_value -= 16\n                # adding button objects so that checkboxes can be clickable\n                self.sidebar_buttons.append(Button(self.width - SIDEBAR_WIDTH + 150, y_value, 10, 10, item))\n                # arcade.draw_rectangle_filled(self.width - SIDEBAR_WIDTH + 150, y_value, 10, 10, arcade.color.BLACK)\n                # arcade.draw_text(item, self.width - SIDEBAR_WIDTH + 10, y_value + 8,\n                # arcade.color.BLACK, 9, width=180, align=\"left\", anchor_x=\"left\", anchor_y=\"top\")\n\n    def on_draw(self):\n        # Clear pixels\n        self.clear()\n\n        arcade.start_render()\n\n        # Draw grid sprites\n        self.grid_sprite_list.draw()\n        self.room_sprite_list.draw()\n\n        # Draw players & sidebar\n        self.player_list.draw()\n        self.draw_sidebar()\n\n        # draw clickable die\n        if self.die_visible:\n            self.die.draw()\n\n        # draw sidebar buttons:\n        for button in self.sidebar_buttons:\n            button.draw()\n\n    # Redraw sprite when sprite moves\n    def on_update(self, delta_time):\n        self.players[0].update()\n        self.run()\n        # for i in range(5):\n        #     rand = random.randrange(0, 4)\n        #     if rand == 0:\n        #         self.player_npcs[i].change_x = 23.94\n        #         rand = random.randrange(0, 4)\n        #         #time.sleep(0.05)\n        #     elif rand == 1:\n        #         self.player_npcs[i].change_y = 23.94\n        #         rand = random.randrange(0, 4)\n        #         #time.sleep(0.05)\n        #     elif rand == 2:\n        #         self.player_npcs[i].change_x = -23.94\n        #         rand = random.randrange(0, 4)\n        #         #time.sleep(0.05)\n        #     elif rand == 3:\n        #         self.player_npcs[i].change_y = -23.94\n        #         rand = random.randrange(0, 4)\n        #         #time.sleep(0.05)\n        #     # self.player_npcs[i].change_x = 23.94\n        #     # time.sleep(0.1)\n        #     # print(self.press)\n        #     # if self.press >= 40:\n        #     #     self.player_npcs[i].change_x = 0\n        #     #     self.player_npcs[i].change_y = 0\n        #     self.player_npcs[i].update()\n\n    # Allow player movement with arrow keys\n    # time delay to allow for sprite to move\n    # one grid square at a time per key press\n    def on_key_press(self, key, modifiers):\n        if key == arcade.key.UP:\n            self.up_pressed = True\n            self.update_player_movement()\n        elif key == arcade.key.DOWN:\n            self.down_pressed = True\n            self.update_player_movement()\n        elif key == arcade.key.LEFT:\n            self.left_pressed = True\n            self.update_player_movement()\n        elif key == arcade.key.RIGHT:\n            self.right_pressed = True\n            self.update_player_movement()\n\n    def on_key_release(self, key, modifiers):\n        if key == arcade.key.UP:\n            self.up_pressed = False\n            self.update_player_movement()\n        elif key == arcade.key.DOWN:\n            self.down_pressed = False\n            self.update_player_movement()\n        elif key == arcade.key.LEFT:\n            self.left_pressed = False\n            self.update_player_movement()\n        elif key == arcade.key.RIGHT:\n            self.right_pressed = False\n            self.update_player_movement()\n\n    def update_player_movement(self):\n        self.players[0].change_x = 0\n        self.players[0].change_y = 0\n\n        if self.up_pressed and not self.down_pressed:\n            self.players[0].change_y = PLAYER_MOVEMENT\n            time.sleep(0.1)\n            self.move_list.append(self.players[0].center_y)\n        elif self.down_pressed and not self.up_pressed:\n            self.players[0].change_y = -PLAYER_MOVEMENT\n            time.sleep(0.1)\n            self.move_list.append(self.players[0].center_y)\n        if self.left_pressed and not self.right_pressed:\n            self.players[0].change_x = -PLAYER_MOVEMENT\n            time.sleep(0.1)\n            self.move_list.append(self.players[0].center_x)\n        elif self.right_pressed and not self.left_pressed:\n            self.players[0].change_x = PLAYER_MOVEMENT\n            time.sleep(0.1)\n            self.move_list.append(self.players[0].center_x)\n        if self.press >= self.limit:\n            self.players[0].change_y = 0\n            self.players[0].change_x = 0\n        # for i in range(self.moves_list):\n        #     if self.players[0].center == self.moves_list[i-1]:\n\n    # event handler for player turn order and npc movement\n    def run(self):\n        rand = random.randrange(0, 4)\n        if self.current_player == 0:\n            if self.right_pressed or self.left_pressed or self.up_pressed or self.down_pressed:\n                self.press += 1\n                print(self.press)\n            if self.press >= self.limit:\n                self.current_player += 1\n        for count, npc in enumerate(self.player_npcs):\n            if self.current_player == 1 + count:\n                self.moves += 1\n                i = 0\n                if self.moves >= self.idle:\n                    for j in range(self.limit):\n                        if rand == 0:\n                            npc.change_x = PLAYER_MOVEMENT\n                            rand = random.randrange(0, 4)\n                            # time.sleep(0.25)\n                            i += 1\n                            npc.update()\n                            time.sleep(0.25)\n                            # self.step = 0\n                        elif rand == 1:\n                            npc.change_y = PLAYER_MOVEMENT\n                            rand = random.randrange(0, 4)\n                            # time.sleep(0.25)\n                            i += 1\n                            npc.update()\n                            time.sleep(0.25)\n                            # self.step = 0\n                        elif rand == 2:\n                            npc.change_x = -PLAYER_MOVEMENT\n                            rand = random.randrange(0, 4)\n                            print(rand)\n                            # time.sleep(0.25)\n                            i += 1\n                            npc.update()\n                            time.sleep(0.25)\n                            # self.step = 0\n                        elif rand == 3:\n                            npc.change_y = -PLAYER_MOVEMENT\n                            rand = random.randrange(0, 4)\n                            print(rand)\n                            i += 1\n                            npc.update()\n                            time.sleep(0.25)\n                            # self.step = 0\n                        # npc.update()\n                    print('next player')\n                    if i >= self.limit:\n                        npc.change_x = 0\n                        npc.change_y = 0\n                    self.current_player += 1\n                    self.moves = 0\n        if self.current_player > len(self.player_npcs):\n            self.press = 0\n            self.current_player = 0\n\n    # Mouse listener\n    def on_mouse_press(self, x, y, button, modifiers):\n\n        # Convert the clicked mouse position into grid coordinates\n        column = int(x // (WIDTH + MARGIN))\n        row = int(y // (HEIGHT + MARGIN))\n\n        print(f\"Click coordinates: ({x}, {y}). Grid coordinates: ({row}, {column})\")\n\n        # Make sure we are on-grid. It is possible to click in the upper right\n        # corner in the margin and go to a grid location that doesn't exist\n        if row >= ROW_COUNT or column >= COLUMN_COUNT:\n            # Simply return from this method since nothing needs updating\n            return\n\n        # 915 - 925,  718 - 728 -16y\n        \"\"\"\n        # Flip the location between 1 and 0.\n        if self.grid[row][column] == 0:\n            self.grid[row][column] = 1\n        else:\n            self.grid[row][column] = 0\n        \"\"\"\n        # Update the sprite colors to match the new grid\n        self.resync_grid_with_sprites()\n\n        # clicking within area of die to roll it, if die is visible\n        if self.die_visible:\n            if (self.die.x - self.die.width / 2 < x < self.die.x + self.die.width / 2\n                    and self.die.y - self.die.height / 2 < y < self.die.y + self.die.height / 2):\n                self.die.roll_die()\n                print(\"Rolled Die\")\n\n        # making boxes clickable\n        for button in self.sidebar_buttons:\n            button.check_click(x, y)\n\n\ndef main():\n    window = arcade.Window(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)\n    startView = StartView(SCREEN_WIDTH, SCREEN_HEIGHT)\n\n    # clueGameView = ClueGameView(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)\n    window.show_view(startView)\n    # ClueGame(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE)\n    # deck = Deck.initialize_cards()\n    arcade.run()\n\n\n# kvdf\nif __name__ == \"__main__\":\n    main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 61c1fca077ee04344ec6ecb02f93337e25a1aa25)
+++ b/main.py	(date 1711571493349)
@@ -38,8 +38,8 @@
         super().__init__()
         self.width = width
         self.height = height
-        self.background_img = arcade.load_texture("../../clue_image.jpeg")
-        arcade.load_font("../../bulletin-gothic/BulletinGothic.otf")
+        self.background_img = arcade.load_texture("images/clue_image.jpeg")
+        arcade.load_font("bulletin-gothic/BulletinGothic.otf")
         self.text_effect = 0
         self.min_font_size_reached = True
         self.max_font_size_reached = False
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"Black\">\n    <option name=\"sdkName\" value=\"Python 3.10 (CS3050-Final-Project)\" />\n  </component>\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.10 (CS3050-Final-Project)\" project-jdk-type=\"Python SDK\" />\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 61c1fca077ee04344ec6ecb02f93337e25a1aa25)
+++ b/.idea/misc.xml	(date 1711571309202)
@@ -1,7 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="Black">
-    <option name="sdkName" value="Python 3.10 (CS3050-Final-Project)" />
-  </component>
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10 (CS3050-Final-Project)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.9" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: .idea/inspectionProfiles/Project_Default.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><component name=\"InspectionProjectProfileManager\">\n  <profile version=\"1.0\">\n    <option name=\"myName\" value=\"Project Default\" />\n    <inspection_tool class=\"PyPep8NamingInspection\" enabled=\"true\" level=\"WEAK WARNING\" enabled_by_default=\"true\">\n      <option name=\"ignoredErrors\">\n        <list>\n          <option value=\"N806\" />\n        </list>\n      </option>\n    </inspection_tool>\n  </profile>\n</component>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/inspectionProfiles/Project_Default.xml b/.idea/inspectionProfiles/Project_Default.xml
--- a/.idea/inspectionProfiles/Project_Default.xml	(revision 61c1fca077ee04344ec6ecb02f93337e25a1aa25)
+++ b/.idea/inspectionProfiles/Project_Default.xml	(date 1711571309201)
@@ -1,10 +1,29 @@
 <component name="InspectionProjectProfileManager">
   <profile version="1.0">
     <option name="myName" value="Project Default" />
+    <inspection_tool class="HtmlUnknownAttribute" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="myValues">
+        <value>
+          <list size="1">
+            <item index="0" class="java.lang.String" itemvalue="Access-Control-Allow-Origin" />
+          </list>
+        </value>
+      </option>
+      <option name="myCustomValuesEnabled" value="true" />
+    </inspection_tool>
     <inspection_tool class="PyPep8NamingInspection" enabled="true" level="WEAK WARNING" enabled_by_default="true">
       <option name="ignoredErrors">
         <list>
           <option value="N806" />
+          <option value="N802" />
+          <option value="N803" />
+        </list>
+      </option>
+    </inspection_tool>
+    <inspection_tool class="PyUnresolvedReferencesInspection" enabled="true" level="WARNING" enabled_by_default="true">
+      <option name="ignoredIdentifiers">
+        <list>
+          <option value="str.__and__" />
         </list>
       </option>
     </inspection_tool>
